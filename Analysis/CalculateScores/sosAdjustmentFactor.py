

"""
Build a season-relative SOS bonus for VALUE scoring.

The output CSV contains:
    team_name, season_year, sos_adj_factor

Interpretation:
    sos_adj_factor is an *additive* bump to apply at the very end of VALUE:
        VOCBP_final = VOCBP_raw + sos_adj_factor

Computation (per season_year):
    sos_z       = (sos - mean_sos_season) / std_sos_season
    bonus_raw   = lambda_bonus * max(0, sos_z)          # one-sided: only rewards tougher slates
    sos_adj_factor = min(bonus_raw, cap) if cap is not None else bonus_raw

Notes:
- This intentionally does NOT adjust individual stats; it is a small, transparent tie‑breaker
  that favors "battle‑tested" players without penalizing low‑SOS players.
- Requires an input CSV with columns: ['team_name','season_year','sos'].
  If you're already storing this in def_off_factors.csv, point input_csv there.
"""

from __future__ import annotations
import os
import numpy as np
import pandas as pd


REQUIRED_COLS = {'team_name', 'season_year', 'sos'}


def build_value_sos_adjustment(
    input_csv: str = "Analysis/CalculateScores/CSV/def_off_factors.csv",
    output_csv: str = "Analysis/CalculateScores/CSV/sos_value_adjustment.csv",
    lambda_bonus: float = 0.05,
    cap: float | None = None,
    verbose: bool = True,
) -> pd.DataFrame:
    """
    Create a CSV with per-team, per-season additive VALUE bumps based on schedule strength.

    Parameters
    ----------
    input_csv : str
        Path to a CSV that includes at least: team_name, season_year, sos.
    output_csv : str
        Where to write the resulting table (team_name, season_year, sos_adj_factor).
    lambda_bonus : float
        Multiplier applied to the season‑relative z‑score of SOS.
        (Typical: 0.03–0.10. Larger ⇒ stronger tie‑breaker.)
    cap : float or None
        Optional maximum bump (e.g., 0.12 caps at +0.12).
    verbose : bool
        If True, prints a brief summary.

    Returns
    -------
    pd.DataFrame
        DataFrame with columns: team_name, season_year, sos_adj_factor, sos_z (for transparency).
    """
    if not os.path.exists(input_csv):
        raise FileNotFoundError(f"Input CSV not found: {input_csv}")

    df = pd.read_csv(input_csv)
    missing = REQUIRED_COLS - set(df.columns)
    if missing:
        raise ValueError(f"Input CSV missing required columns: {missing}")

    # Ensure expected dtypes
    df['season_year'] = df['season_year'].astype(int)

    # Compute season-relative z for SOS
    def _season_z(g: pd.DataFrame) -> pd.Series:
        mu = g['sos'].mean()
        sd = g['sos'].std(ddof=0)
        if not np.isfinite(sd) or sd == 0:
            # Degenerate case: all equal SOS in this season
            return pd.Series(0.0, index=g.index)
        return (g['sos'] - mu) / sd

    df['sos_z'] = df.groupby('season_year', group_keys=False).apply(_season_z)

    # One-sided, additive bump
    bonus = lambda_bonus * np.maximum(0.0, df['sos_z'].values)
    if cap is not None:
        bonus = np.minimum(bonus, cap)

    out = df[['team_name', 'season_year']].copy()
    out['sos_adj_factor'] = bonus
    out['sos_z'] = df['sos_z'].values  # keep for transparency

    # Write CSV
    os.makedirs(os.path.dirname(output_csv), exist_ok=True)
    out.to_csv(output_csv, index=False)

    if verbose:
        by_season = out.groupby('season_year')['sos_adj_factor'].agg(['mean', 'std', 'min', 'max'])
        print("=== SOS VALUE ADJUSTMENT SUMMARY ===")
        print(f"lambda_bonus = {lambda_bonus}, cap = {cap}")
        print(by_season.tail(10).to_string())
        print(f"\nSaved to: {os.path.abspath(output_csv)}")

    return out


# ------------------------------------------------------------------
# Fetching / applying helpers (mirrors adjustmentFactor.py patterns)
# ------------------------------------------------------------------

def get_sos_adjustment_year(
    season_year: int,
    csv_path: str = "Analysis/CalculateScores/CSV/sos_value_adjustment.csv",
    include_z: bool = True,
) -> pd.DataFrame:
    """
    Return per-team SOS value adjustments for a given season.

    Parameters
    ----------
    season_year : int
        Season to filter.
    csv_path : str
        Path to the CSV generated by build_value_sos_adjustment().
    include_z : bool
        If True, include the 'sos_z' transparency column.

    Returns
    -------
    pd.DataFrame with columns: ['team_name','season_year','sos_adj_factor', ('sos_z')]
    """
    df = pd.read_csv(csv_path)
    season_df = df[df['season_year'] == int(season_year)].copy()
    cols = ['team_name', 'season_year', 'sos_adj_factor'] + (['sos_z'] if include_z and 'sos_z' in season_df.columns else [])
    return season_df[cols]


def get_sos_adjustment_team_year(
    team_name: str,
    season_year: int,
    csv_path: str = "Analysis/CalculateScores/CSV/sos_value_adjustment.csv",
) -> dict:
    """
    Get the SOS value adjustment for a specific team in a given season.

    Returns
    -------
    dict with keys: {'sos_adj_factor', 'sos_z'} (sos_z included if available)
    """
    season_df = get_sos_adjustment_year(season_year, csv_path=csv_path, include_z=True)
    team_df = season_df[season_df['team_name'] == team_name]
    if team_df.empty:
        raise ValueError(f"No SOS adjustment found for {team_name} in {season_year}")
    row = team_df.iloc[0]
    out = {'sos_adj_factor': float(row['sos_adj_factor'])}
    if 'sos_z' in row:
        out['sos_z'] = float(row['sos_z'])
    return out


def apply_sos_bonus_to_value(
    vocbp_raw: float,
    team_name: str,
    season_year: int,
    csv_path: str = "Analysis/CalculateScores/CSV/sos_value_adjustment.csv",
) -> float:
    """
    Apply the additive SOS value bump to a single raw VOCBP score.

    VOCBP_final = vocbp_raw + sos_adj_factor
    """
    adj = get_sos_adjustment_team_year(team_name, season_year, csv_path=csv_path)
    return float(vocbp_raw) + float(adj['sos_adj_factor'])


def apply_sos_bonus_to_value_df(
    value_df: pd.DataFrame,
    season_year: int,
    team_col: str = 'prev_team_name',
    in_col: str = 'vocbp_raw',
    out_col: str = 'vocbp',
    csv_path: str = "Analysis/CalculateScores/CSV/sos_value_adjustment.csv",
) -> pd.DataFrame:
    """
    Add the SOS additive bump to an entire DataFrame of player VALUEs.

    Parameters
    ----------
    value_df : pd.DataFrame
        Should contain the player's team column (e.g., previous team) and a raw value column.
    season_year : int
        Season for which to fetch the team SOS adjustments.
    team_col : str
        Column in value_df with the team key (default: 'prev_team_name').
    in_col : str
        Column with the unadjusted VALUE (default: 'vocbp_raw').
    out_col : str
        Column name for the adjusted VALUE (default: 'vocbp').
    csv_path : str
        Path to the sos_value_adjustment.csv.

    Returns
    -------
    pd.DataFrame
        Copy of value_df with 'sos_adj_factor' merged and a new/updated `out_col` = `in_col` + sos_adj_factor.
    """
    out = value_df.copy()
    sos_df = get_sos_adjustment_year(season_year, csv_path=csv_path, include_z=True)

    # Prepare merge frame keyed by team
    merge_cols = ['team_name', 'sos_adj_factor'] + (['sos_z'] if 'sos_z' in sos_df.columns else [])
    sos_keyed = sos_df[merge_cols].rename(columns={'team_name': team_col})

    out = out.merge(sos_keyed, on=team_col, how='left')

    # If the raw value column is missing, just return with the factor merged
    if in_col not in out.columns:
        return out

    # Fill missing sos_adj_factor with 0.0 (no bump) and compute final value
    out['sos_adj_factor'] = out['sos_adj_factor'].fillna(0.0)
    out[out_col] = out[in_col] + out['sos_adj_factor']

    return out


if __name__ == "__main__":
    # Default run with gentle tie-breaker settings
    build_value_sos_adjustment(
        input_csv="Analysis/CalculateScores/CSV/def_off_factors.csv",
        output_csv="Analysis/CalculateScores/CSV/sos_value_adjustment.csv",
        lambda_bonus=0.1,
        cap=0.2,
        verbose=True,
    )